## 동적할당
### 개념
* new
* delete delete[]
### 연습문제 
* a,b를 입력받아 a*b 크기의 이중배열을 동적할당하고 각각의 [a][b] 에 a * b 값을 넣은 뒤 배열 전체를 출력하고 해제해 보자
### 심화
## 포인터
### 개념
* 모든 것을 스택에 담을 수는 없다
* 힙에 담아주는 동적할당
* 동적길이의 배열 동적할당만으로 사용 가능
* new
    * > int * arr = new int[6];
    * 동적할당 해준다
    * 포인터를 반환
* delete
    * > delete someObject;
    * 동적 할당한 것을 해제
* delete []
    * > delete [] arr;
    * 배열을 동적할당 해제 할 때 사용한다
    * 이중배열을 다 풀어주는 것이 아님
    * 그냥 이중배열을 사용하지 않는 꼼수
        * arr[a][b] -> arr[a*b] 
        * 사용법 : arr[x*b+y]
* 함수에서 배열을 반환하기 위해선 반드시 동적할당을 해야한다
    * 리턴값은 포인터에 불과하기 때문이다
### 연습문제 
* a,b를 입력받아 a*b 크기의 이중배열을 동적할당하고 각각의 [a][b] 에 a * b 값을 넣은 뒤 배열 전체를 출력하고 해제해 보자
### 심화
* garbage collector (GC)
* heap
* stack

## class
``` cpp
class Foo{
// 외부에서 접근할 수 없는 private
  private:
  // 멤버변수
    int bar;
    float bar2;
// 외부에서 접근 가능한 public
  public:
  // 생성자
    Foo(int a){
        //this 는 자신의 포인터
        this -> bar = a;
    }
    // 메서드
    int method(){
        return bar;
    }
    // 소멸자
    ~Foo(){
        
    }
};

int main(){
    // 생성자를 활용한 인스턴스 생성
    Foo foo(1);
    // 메서드 사용
    std::cout<<foo.method();
    return 0;
}
```

* PS에서 쓰일 일은 거의 없지만 추후 다룰 STL의 구조를 이해하는데 도움이될 것이고, 일부 자료구조를 직접 구현해야하는경우 클래스가 사용된다.

* 인스턴스
    * 클래스를 선언하고 인스턴스로 만들어 주면서 실제로 사용하게 된다
    * 마치 자료형과 같다
* 생성자 소멸자
    * 클래스의 인스턴스가 생성 될 때 생성자가 불리고, 소멸될 때 소멸자가 불린다
* 은닉
    * private: 아래의 멤버변수, 메소드들은 클래스 외부에서 접근이 불가능하다
    * public: 아래의 멤버변수, 메소드들은 클래스 외부에서도 자유롭게 접근할 수 있다
* 메소드
    * 클래스에서 사용하는 함수라고 보면 된다
    * foo.a() 와 같이 사용
    * 클래스 내부에서는 a() 와 같이 접근
* 멤버변수
    * foo.a 와 같이 접근
        * public한 경우만 가능
    * 클래스 내부에서 사용할 땐 this -> a 또는 a 와 같이 접근
        * private 한 경우에도 사용 가능하다
        * this-> 를 적어주면 메소드 안의 지역변수가 아닌 클래스의 멤버변수임을 명시하는 것

### 심화
* 클래스의 인스턴스는 실제로 어떻게 저장되는가?
## exception
``` cpp
try{
/*do something*/
}catch(Execption e){
/* catch error here */
}
```
* PS에서 쓰일 일은 거의 없다 
* 에러가 발생할 때 프로그램을 종료시키는 것이 아니라 적절히 처리하기 위해 사용함
