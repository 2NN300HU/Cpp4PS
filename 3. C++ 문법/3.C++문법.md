# 3. C++ 문법
> * 기초문법만으로도 충분히 코딩이 가능하지만 C++만의 문법을 통해 더 편한 코딩을 해보자
> * C에는 없는 유용한 문법, 알아둬야 할 문법들을 다룸
## auto
* > auto i = fomeFunc();
* 타입 추론이 가능할 경우 자료형 auto으로 선언하게 되면 자동으로 자료형을 잡아준다
* 자료형이 긴 상황의 코드를 짧게 줄여준다
* 타입추론이 가능하다는 것은 초기화 되며 선언된다는 의미이다
    * 초기화 하는 값의 자료형으로 선언된다는 것
## Reference
* > int& ref = origin;
* 포인터가 변수의 주소값을 담는 변수에 불과하다면, 레퍼런스는 아예 그 변수의 별칭을 만들어준다
* > a = origin; origin =a;
* 포인터와 달리 참조한 변수 그 자체처럼 사용하면 된다
* 반드시 선언시에 초기화 해주어야되고, 그 이후 재할당이 불가능하다
* > int foo(int & ref) 
* 주로 사용되는 상황은 역시나 함수에서 값을 넘겨받을 때이다
> Use reference wherever you can, pointers wherever you must.
* 레퍼런스를 쓸수 있을 땐 레퍼런스를 사용하고 포인터를 써야만 할때 포인터를 쓰자
## Range based For
* > for(int i : arr){}
* 순환할 수 있는 객체들은 범위 기반 for문을 통해 쉽게 순환할 수 있다
* > for(auto & i : arr){}
* auto 를 활용하여 타입을 복잡하게 적지 않아도 되며, 배열의 각 요소를 레퍼런스로 받아 복사하지 않고 값을 활용할 수 있다
## class
``` cpp
class Foo{
// 외부에서 접근할 수 없는 private
  private:
  // 멤버변수
    int bar;
    float bar2;
// 외부에서 접근 가능한 public
  public:
  // 생성자
    Foo(int a){
        //this 는 자신의 포인터
        this -> bar = a;
    }
    // 메서드
    int method(){
        return bar;
    }
    // 소멸자
    ~Foo(){
        
    }
};

int main(){
    // 생성자를 활용한 인스턴스 생성
    Foo foo(1);
    // 메서드 사용
    std::cout<<foo.method();
    return 0;
}
```

* PS에서 쓰일 일은 거의 없지만 추후 다룰 STL의 구조를 이해하는데 도움이될 것이고, 일부 자료구조를 직접 구현해야하는경우 클래스가 사용된다.

* 인스턴스
    * 클래스를 선언하고 인스턴스로 만들어 주면서 실제로 사용하게 된다
    * 마치 자료형과 같다
* 생성자 소멸자
    * 클래스의 인스턴스가 생성 될 때 생성자가 불리고, 소멸될 때 소멸자가 불린다
* 은닉
    * private: 아래의 멤버변수, 메소드들은 클래스 외부에서 접근이 불가능하다
    * public: 아래의 멤버변수, 메소드들은 클래스 외부에서도 자유롭게 접근할 수 있다
* 메소드
    * 클래스에서 사용하는 함수라고 보면 된다
    * foo.a() 와 같이 사용
    * 클래스 내부에서는 a() 와 같이 접근
* 멤버변수
    * foo.a 와 같이 접근
        * public한 경우만 가능
    * 클래스 내부에서 사용할 땐 this -> a 또는 a 와 같이 접근
        * private 한 경우에도 사용 가능하다
        * this-> 를 적어주면 메소드 안의 지역변수가 아닌 클래스의 멤버변수임을 명시하는 것

### 심화
* 클래스의 인스턴스는 실제로 어떻게 저장되는가?
## exception
``` cpp
try{
/*do something*/
}catch(Execption e){
/* catch error here */
}
```
* PS에서 쓰일 일은 거의 없다 
* 에러가 발생할 때 프로그램을 종료시키는 것이 아니라 적절히 처리하기 위해 사용함
## Skills
* https://www.acmicpc.net/blog/view/106



